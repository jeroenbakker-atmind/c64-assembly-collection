use std::ops::BitAnd;

const BITMASKS_U16: [u16; 16] = [
    0b1000000000000000,
    0b0100000000000000,
    0b0010000000000000,
    0b0001000000000000,
    0b0000100000000000,
    0b0000010000000000,
    0b0000001000000000,
    0b0000000100000000,
    0b0000000010000000,
    0b0000000001000000,
    0b0000000000100000,
    0b0000000000010000,
    0b0000000000001000,
    0b0000000000000100,
    0b0000000000000010,
    0b0000000000000001,
];
const BITMASKS_U64: [u64; 16] = [
    0b1100000011000000000000000000000000000000000000000000000000000000_u64,
    0b0011000000110000000000000000000000000000000000000000000000000000,
    0b0000110000001100000000000000000000000000000000000000000000000000,
    0b0000001100000011000000000000000000000000000000000000000000000000,
    0b0000000000000000110000001100000000000000000000000000000000000000,
    0b0000000000000000001100000011000000000000000000000000000000000000,
    0b0000000000000000000011000000110000000000000000000000000000000000,
    0b0000000000000000000000110000001100000000000000000000000000000000,
    0b0000000000000000000000000000000011000000110000000000000000000000,
    0b0000000000000000000000000000000000110000001100000000000000000000,
    0b0000000000000000000000000000000000001100000011000000000000000000,
    0b0000000000000000000000000000000000000011000000110000000000000000,
    0b0000000000000000000000000000000000000000000000001100000011000000,
    0b0000000000000000000000000000000000000000000000000011000000110000,
    0b0000000000000000000000000000000000000000000000000000110000001100,
    0b0000000000000000000000000000000000000000000000000000001100000011,
];

/// Encode a char to a 16 bit representation. One 1 out of 4 pixels are stored.
pub fn encode_char(char_bits: u64) -> u16 {
    let mut result = 0;
    for (mask_u64, mask_u16) in BITMASKS_U64.iter().zip(BITMASKS_U16) {
        if char_bits.bitand(mask_u64) != 0 {
            result |= mask_u16
        }
    }

    result
}

pub fn decode_char(encoded: u16) -> u64 {
    let mut result = 0;

    for (mask_u64, mask_u16) in BITMASKS_U64.iter().zip(BITMASKS_U16) {
        if encoded.bitand(mask_u16) != 0 {
            result |= mask_u64
        }
    }

    result
}
